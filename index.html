<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrcpy Desktop</title>
    <style>
        :root {
            --body-bg: #121212;
            --header-bg: #1E1E1E;
            --card-bg: #1E1E1E;
            --card-border: #2C2C2C;
            --input-bg: #2C2C2C;
            --input-border: #3C3C3C;
            --text-color: #E8EAED;
            --label-color: #B0BEC5;
            --dim-text-color: #8A8A8A;
            --placeholder-color: #6E6E6E;
            --primary-accent: #1A73E8;
            --primary-accent-dark: #1557B0;
            --secondary-accent: #F4B400;
            --secondary-accent-dark: #D19400;
            --success-color: #34C759;
            --error-color: #F44336;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --surface-elevation: #242424;
            --modal-bg: var(--card-bg);
            --modal-text: var(--text-color);
        }

        .light-mode {
            --body-bg: #FFFFFF;
            --header-bg: #F8F9FA;
            --card-bg: #FFFFFF;
            --card-border: #DADCE0;
            --input-bg: #F1F3F4;
            --input-border: #DADCE0;
            --text-color: #202124;
            --label-color: #5F6368;
            --dim-text-color: #80868B;
            --placeholder-color: #A8ACB0;
            --primary-accent: #1A73E8;
            --primary-accent-dark: #174EA6;
            --secondary-accent: #D19400;
            --secondary-accent-dark: #D19400;
            --success-color: #34C759;
            --error-color: #D93025;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --surface-elevation: #FFFFFF;
            --modal-bg: var(--card-bg);
            --modal-text: var(--text-color);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--body-bg);
            color: var(--text-color);
            font-family: 'Roboto', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 0;
            transition: background-color 0.3s ease;
        }

        header {
            background: var(--header-bg);
            padding: 16px 24px;
            box-shadow: 0 1px 3px var(--shadow-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            position: sticky;
            top: 0;
            z-index: 1000;
            transition: transform 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
        }

        header.hidden {
            transform: translateY(-100%);
        }

        .title {
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--text-color);
            letter-spacing: 0.02em;
            transition: color 0.3s ease;
        }

        .theme-toggle {
            display: flex;
            align-items: center;
        }

        .theme-toggle input[type="checkbox"] {
            display: none;
        }

        .toggle-label {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .toggle-label:hover {
            opacity: 0.9;
        }

        .toggle-label .slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--input-bg);
            border-radius: 12px;
            transition: background-color 0.4s ease;
        }

        .light-mode .toggle-label .slider {
            background-color: var(--primary-accent);
        }

        .slider::before {
            content: '';
            position: absolute;
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: #FFFFFF;
            border-radius: 50%;
            transition: transform 0.4s ease;
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        .toggle-label .icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.4s ease, stroke 0.4s ease;
        }

        .toggle-label .icon svg {
            width: 100%;
            height: 100%;
            stroke: currentColor;
            fill: none;
        }

        .toggle-label .icon.moon {
            left: 4px;
            opacity: 1;
            stroke: var(--text-color);
        }

        .toggle-label .icon.sun {
            right: 4px;
            opacity: 0;
            stroke: #F4B400;
        }

        #themeToggle:checked + .toggle-label .slider::before {
            transform: translateX(24px);
        }

        #themeToggle:checked + .toggle-label .icon.moon {
            opacity: 0;
        }

        #themeToggle:checked + .toggle-label .icon.sun {
            opacity: 1;
        }

        .light-mode .toggle-label .icon.moon {
            stroke: #FFFFFF;
        }

        .main-content {
            flex-grow: 1;
            width: 100%;
            max-width: 960px;
            margin: 24px auto;
            padding: 0 16px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .card-grid {
            display: contents;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            width: 100%;
        }

        .card {
            background: var(--card-bg);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-color);
            border: 1px solid var(--card-border);
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .card h3 {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--primary-accent);
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--card-border);
            transition: color 0.3s ease, border-color 0.3s ease;
        }

        label {
            display: block;
            font-size: 0.875rem;
            color: var(--label-color);
            margin-top: 12px;
            margin-bottom: 4px;
            text-align: left;
            font-weight: 400;
            transition: color 0.3s ease;
        }

        small {
            color: var(--dim-text-color);
            font-size: 0.75rem;
            display: block;
            margin-top: 20px;
            margin-bottom: 15px;
            transition: color 0.3s ease;
        }

        select, input[type="text"], input[type="number"] {
            width: 100%;
			margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            font-size: 0.875rem;
            background: var(--input-bg);
            color: var(--text-color);
            transition: all 0.2s ease;
            outline: none;
        }

        input::placeholder {
            color: var(--placeholder-color);
        }

        select:focus, input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--primary-accent);
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
            background: var(--input-bg);
        }

        select:disabled, input:disabled {
            background-color: var(--card-border);
            color: var(--dim-text-color);
            cursor: not-allowed;
            opacity: 0.7;
            border-color: var(--input-border);
        }

        label.disabled {
            opacity: 0.6;
            color: var(--dim-text-color);
        }

        #ipField {
        }

        input[type="number"] {
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: left;
            margin-top: 12px;
            max-width: 100%;
        }

        .checkbox-group label {
            background: var(--input-bg);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            min-width: 80px;
            text-align: center;
            border: 1px solid var(--input-border);
            margin-top: 0;
            margin-bottom: 0;
            flex-grow: 1;
            flex-basis: 0;
        }

        .checkbox-group input[type="checkbox"] {
            display: none;
        }

        .checkbox-group input[type="checkbox"]:checked + label {
            background: var(--primary-accent);
            color: #FFFFFF;
            border-color: var(--primary-accent-dark);
        }

        .checkbox-group input[type="checkbox"]:disabled + label {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--input-bg);
            border-color: var(--input-border);
            color: var(--dim-text-color);
        }

        .checkbox-group label:hover:not(.disabled) {
            background: var(--card-border);
        }

        .command-card .collapsible {
            background-color: var(--input-bg);
            color: var(--label-color);
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            margin-top: 12px;
            box-shadow: none;
            font-size: 0.875rem;
            text-transform: none;
            width: 100%;
        }

        .command-card .collapsible:hover {
            background-color: var(--card-border);
        }

        .command-card .collapsible:after {
            content: '\002B';
            color: var(--primary-accent);
            font-weight: bold;
            float: right;
            margin-left: 5px;
        }

        .command-card .collapsible.active:after {
            content: "\2212";
        }

        .command-card .content {
            padding: 0 12px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            background-color: var(--input-bg);
            border-radius: 0 0 8px 8px;
            text-align: left;
            margin-bottom: 0;
            border: 1px solid var(--input-border);
            border-top: none;
            margin-top: 0;
        }

        .command-card .content.expanded {
            padding-top: 12px;
            padding-bottom: 12px;
        }

        .command-card pre {
            background: none;
            padding: 0;
            border: none;
            box-shadow: none;
            margin: 0;
            font-size: 0.75rem;
            color: var(--text-color);
            white-space: pre-wrap;
            word-break: break-all;
        }

        .full-width-actions {
            width: 100%;
            max-width: 960px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            width: 100%;
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 500;
            text-transform: none;
            cursor: pointer;
            text-align: center;
            letter-spacing: 0.02em;
            transition: all 0.3s ease;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #startButton {
            background: var(--primary-accent);
            color: #FFFFFF;
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.3);
        }

        #startButton:hover:not(.button-disabled) {
            background: var(--primary-accent-dark);
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.4);
            transform: translateY(-1px);
        }

        #pairButton {
            background: var(--primary-accent);
            color: #FFFFFF;
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.3);
             margin-top: 15px;
        }

        #pairButton:hover:not(.button-disabled) {
            background: var(--primary-accent-dark);
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.4);
            transform: translateY(-1px);
        }

        #updateButton {
            background: var(--input-bg);
            color: var(--text-color);
            box-shadow: 0 1px 4px var(--shadow-color);
            border: 1px solid var(--input-border);
        }

        #updateButton:hover:not(.button-disabled) {
            background: var(--card-border);
            box-shadow: 0 2px 8px var(--shadow-color);
            transform: translateY(-1px);
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #FFFFFF;
            animation: spin 0.8s ease-in-out infinite;
            margin-left: 8px;
            vertical-align: middle;
        }

        .modal-content .spinner {
             border-color: rgba(0, 0, 0, 0.3);
             border-top-color: #000000;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .button-disabled {
            opacity: 0.7;
            cursor: not-allowed;
            box-shadow: none;
            background: var(--input-bg);
            color: var(--dim-text-color);
            transform: none;
            border-color: var(--input-border);
        }
         /* Ensure spinners in disabled buttons are still visible */
        .button-disabled .spinner {
             border-top-color: var(--dim-text-color);
        }


        #statusMessage {
            padding: 10px 16px;
            border-radius: 8px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            font-weight: 400;
            min-height: 20px;
            border: 1px solid transparent;
            margin-top: 12px;
        }

        .status-success {
            background: var(--success-color);
            color: #FFFFFF;
            border-color: var(--success-color);
        }

        .status-error {
            background: var(--error-color);
            color: #FFFFFF;
            border-color: var(--error-color);
        }

        footer {
            font-size: 0.875rem;
            color: var(--dim-text-color);
            padding: 16px 0;
            text-align: center;
            margin-top: auto;
            width: 100%;
            transition: color 0.3s ease;
        }

        footer a {
            color: var(--primary-accent);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        footer a:hover {
            color: var(--primary-accent-dark);
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            header {
                padding: 12px 16px;
            }

            .title {
                font-size: 1.25rem;
            }

            .toggle-label {
                width: 40px;
                height: 20px;
                border-radius: 10px;
            }

            .slider::before {
                height: 16px;
                width: 16px;
                left: 2px;
                bottom: 2px;
            }

            #themeToggle:checked + .toggle-label .slider::before {
                transform: translateX(20px);
            }

            .toggle-label .icon {
                width: 14px;
                height: 14px;
            }

            .toggle-label .icon.moon {
                left: 3px;
            }

            .toggle-label .icon.sun {
                right: 3px;
            }

            .main-content {
                padding: 0 12px;
                margin: 16px auto;
            }

            .card-grid {
                grid-template-columns: 1fr;
            }

            .card {
                padding: 12px;
            }

            .card h3 {
                font-size: 1.125rem;
                margin-bottom: 12px;
            }

            select, input[type="text"], input[type="number"], button {
                padding: 8px;
                font-size: 0.875rem;
            }

            label {
                font-size: 0.75rem;
            }

            .checkbox-group label {
                font-size: 0.75rem;
                min-width: unset;
                flex-basis: auto;
            }

            .command-card .collapsible {
                font-size: 0.875rem;
                padding: 8px;
            }

            .command-card pre {
                font-size: 0.75rem;
            }
        }

        /* --- QR Modal Styles --- */
        #qrModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
             /* Keep display: none; initially, JS will change it to flex */
        }

        #qrModal {
            background: var(--modal-bg);
            color: var(--modal-text);
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px var(--shadow-color);
            border: 1px solid var(--card-border);
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease;
            box-sizing: border-box;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #qrModal h3 {
            color: var(--primary-accent);
            font-size: 1.25rem;
            margin-bottom: 16px;
            transition: color 0.3s ease;
        }

        #qrModal p {
             color: var(--modal-text);
             font-size: 1rem;
             margin-bottom: 16px;
             line-height: 1.5;
             transition: color 0.3s ease;
             text-align: left;
             width: 100%;
        }

        #qrModal small {
             color: var(--dim-text-color);
             font-size: 0.875rem;
             display: block;
             margin-top: 8px;
             transition: color 0.3s ease;
             text-align: center;
             width: 100%;
        }

        #qrcode {
            width: 200;
            height: 200;
            margin: 20px auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #FFFFFF;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Ensure QR code generated inside #qrcode is centered */
        #qrcode canvas, #qrcode img {
             margin: 0 auto !important;
             display: block;
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            color: var(--dim-text-color);
            cursor: pointer;
            transition: color 0.3s ease;
            line-height: 1;
            padding: 5px;
        }

        .close-button:hover {
            color: var(--text-color);
        }

        #qrModalStatus {
             text-align: center;
             min-height: 20px;
             margin-top: 10px;
             font-size: 0.9rem;
             color: var(--modal-text);
        }

        #qrConnectButton {
             margin-top: 20px;
        }

         /* Hide button text when spinner is showing in modal button */
         #qrConnectButton .button-text {
             display: inline-block;
         }

         #qrConnectButton .spinner + .button-text {
             display: none;
         }
		.rotate-button-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			margin-top: 12px;
			gap: 8px; /* Space between label and button */
		}
		
		.rotate-button-label {
			font-size: 0.875rem;
			color: var(--label-color);
			font-weight: 400;
			transition: color 0.3s ease;
		}

		.rotate-button-label.disabled {
			opacity: 0.6;
			color: var(--dim-text-color);
		}

		/* Rotate Button */
		#rotateButton {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background: var(--secondary-accent);
			color: #FFFFFF;
			border: none;
			padding: 0;
			display: flex;
			justify-content: center;
			align-items: center;
			box-shadow: 0 2px 8px rgba(244, 180, 0, 0.3);
			cursor: pointer;
			position: relative;
			transition: all 0.3s ease;
		}

		#rotateButton:hover:not(.button-disabled) {
			background: var(--secondary-accent-dark);
			box-shadow: 0 4px 12px rgba(244, 180, 0, 0.4);
			transform: scale(1.1);
		}

		#rotateButton.button-disabled {
			opacity: 0.7;
			cursor: not-allowed;
			background: var(--input-bg);
			box-shadow: none;
			transform: none;
		}

		#rotateButton .rotate-icon {
			width: 20px;
			height: 20px;
			stroke: #FFFFFF;
			transition: stroke 0.3s ease;
		}

		#rotateButton.button-disabled .rotate-icon {
			stroke: var(--dim-text-color);
		}

		#rotateButton .spinner {
			position: absolute;
			width: 16px;
			height: 16px;
			border: 2px solid rgba(255, 255, 255, 0.3);
			border-top-color: #FFFFFF;
		}

		#rotateButton.button-disabled .spinner {
			border-top-color: var(--dim-text-color);
		}
    </style>
</head>
<body>
    <header id="header">
        <div class="title">Scrcpy Desktop</div>
        <div class="theme-toggle">
            <input type="checkbox" id="themeToggle" aria-label="Toggle theme">
            <label for="themeToggle" class="toggle-label">
                <span class="icon moon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
                    </svg>
                </span>
                <span class="slider"></span>
                <span class="icon sun">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="4"></circle>
                        <path d="M12 2v2"></path>
                        <path d="M12 20v2"></path>
                        <path d="M4.93 4.93l1.41 1.41"></path>
                        <path d="M17.66 17.66l1.41 1.41"></path>
                        <path d="M2 12h2"></path>
                        <path d="M20 12h2"></path>
                        <path d="M6.34 17.66l-1.41 1.41"></path>
                        <path d="M19.07 4.93l-1.41 1.41"></path>
                    </svg>
                </span>
            </label>
        </div>
    </header>

    <main class="main-content">
        <div class="card-grid">
            <div class="card connection-settings">
                <h3>Connection</h3>
                <label for="mode">Mode:</label>
                <select id="mode" onchange="toggleIpField()">
                    <option value="usb">USB</option>
                    <option value="wifi">Wi-Fi</option>
                </select>
                <div id="ipField">
                    <label for="ipAddress" style="margin-top: 12px;">Device IP:</label>
                    <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.100">
                    <small>Enter IP for direct Wi-Fi connection. Auto IP detection via USB also available when switching to Wi-Fi mode.</small>
                    <button id="pairButton" onclick="startQrPairing()">
                        Pair with QR Code
                    </button>
                </div>
            </div>

            <div class="card display-settings">
                <h3>Display</h3>
                <label for="resolution" id="resolutionLabel">Resolution:</label>
                <select id="resolution">
                    <option value="480x320">480x320</option>
                    <option value="1024x600">1024x600</option>
                    <option value="1280x720">1280x720</option>
                    <option value="1280x800">1280x800</option>
                    <option value="1366x768">1366x768</option>
                    <option value="1440x900">1440x900</option>
                    <option value="1600x900">1600x900</option>
                    <option value="1680x1050">1680x1050</option>
                    <option value="1920x1080" selected>1920x1080</option>
                    <option value="1920x1200">1920x1200</option>
                    <option value="2560x1440">2560x1440</option>
                    <option value="2560x1600">2560x1600</option>
                    <option value="3200x1800">3200x1800</option>
                    <option value="3840x2160">3840x2160</option>
                </select>
                <input type="text" id="customResolution" placeholder="Custom Resolution (e.g., 1920x1080)">

                <label for="dpi" id="dpiLabel">DPI:</label>
                <select id="dpi">
                    <option value="160" selected>160dpi</option>
                    <option value="240">240dpi</option>
                    <option value="320">320dpi</option>
                    <option value="480">480dpi</option>
                    <option value="640">640dpi</option>
                </select>
                <input type="number" id="customDpi" placeholder="Custom DPI (e.g., 120)">

                <label for="maxFps">Max FPS:</label>
                <select id="maxFps">
                    <option value="--max-fps=30">30 FPS</option>
                    <option value="--max-fps=60" selected>60 FPS</option>
                    <option value="--max-fps=120">120 FPS</option>
                    <option value="--max-fps=240">240 FPS</option>
                </select>

                <label for="rotationLock" id="rotationLockLabel">Orientation Lock:</label>
                <select id="rotationLock">
                    <option value="--capture-orientation=0">Default (0°)</option>
                    <option value="--capture-orientation=90">Rotate Right (90°)</option>
                    <option value="--capture-orientation=180">Flip Upside Down (180°)</option>
                    <option value="--capture-orientation=270">Rotate Left (270°)</option>
                </select>
            </div>

            <div class="card performance-settings">
                <h3>Performance</h3>
                <label for="bitrate">Bitrate:</label>
                <select id="bitrate">
                    <option value="-b 2M">2 Mbps</option>
                    <option value="-b 5M">5 Mbps</option>
                    <option value="-b 8M" selected>8 Mbps</option>
                </select>
                <input type="number" id="customBitrate" placeholder="Custom Bitrate (Mbps)">
                <small>Higher bitrate = better quality, more bandwidth.</small>
            </div>

            <div class="card additional-options">
                <h3>Additional Options</h3>
                <label style="margin-top: 0;">Toggle features:</label>
                <small>Select options below.</small>
                <div class="checkbox-group">
                    <input type="checkbox" id="noPowerOn" value="--no-power-on">
                    <label for="noPowerOn">No Power On</label>
                    <input type="checkbox" id="turnScreenOff" value="--turn-screen-off" checked>
                    <label for="turnScreenOff">Turn Screen Off</label>
                    <input type="checkbox" id="powerOffOnClose" value="--power-off-on-close">
                    <label for="powerOffOnClose">Power Off On Close</label>
                    <input type="checkbox" id="noAudio" value="--no-audio">
                    <label for="noAudio">No Audio</label>
                    <input type="checkbox" id="fullscreen" value="-f">
                    <label for="fullscreen">Fullscreen</label>
                    <input type="checkbox" id="noControl" value="--no-control">
                    <label for="noControl">No Control</label>
                </div>
            </div>

			<div class="card display-config">
				<h3>Display Mode</h3>
				<label style="margin-top: 0;">Choose display output:</label>
				<small>Options are mutually exclusive.</small>
				<div class="checkbox-group">
					<input type="checkbox" id="useVirtualDisplay" checked>
					<label for="useVirtualDisplay">Virtual Display</label>
					<input type="checkbox" id="useNativeTaskbar">
					<label for="useNativeTaskbar">Native Taskbar (Android 12+)</label>
					<input type="checkbox" id="useSamsungDex">
					<label for="useSamsungDex">Samsung DeX</label>
				</div>
				<div class="rotate-button-container">
					<label for="rotateButton" class="rotate-button-label">Rotate Screen</label>
					<button id="rotateButton" onclick="rotateScreen()" disabled class="button-disabled">
						<svg class="rotate-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M23 4v6h-6"></path>
							<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
						</svg>
						<span id="rotateSpinner" class="spinner" style="display: none;"></span>
					</button>
				</div>
			</div>

            <div class="card command-card">
                <h3>Scrcpy Command</h3>
                <button class="collapsible">Show/Hide Command</button>
                <div class="content">
                    <pre id="scrcpyCommandDisplay">Press Start to see the command...</pre>
                </div>
            </div>
        </div>

        <div class="full-width-actions">
            <button id="startButton" onclick="startScrcpy()">
                Start
                <span id="spinner" class="spinner" style="display: none;"></span>
            </button>
            <button id="updateButton" onclick="updateApp()">
                Update App
                <span id="updateSpinner" class="spinner" style="display: none;"></span>
            </button>
            <div id="statusMessage"></div>
        </div>
    </main>

	<div id="qrModalOverlay" style="display: none;">
        <div id="qrModal">
            <span class="close-button" onclick="hideQrModal()">×</span>
            <h3 id="qrModalTitle">Connect Phone to PC (Wireless Debugging)</h3>
            <p id="qrModalMessage"></p>
            <div id="qrcode"></div>
            <div id="qrModalStatus">Initializing...</div>
            <button id="qrConnectButton" class="button-disabled" disabled onclick="startScrcpyFromQr()">
                 Start
                 <span id="qrSpinner" class="spinner" style="display: none;"></span>
            </button>
        </div>
	</div>

    <footer>
        © 2025 <a href="https://github.com/serifpersia" target="_blank">serifpersia</a>. All rights reserved.
    </footer>

	<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <script>
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;
        const header = document.getElementById('header');
        let lastScrollY = window.scrollY;
        let hideTimeout;

        const savedTheme = localStorage.getItem('theme') || 'dark';
        if (savedTheme === 'light') {
            body.classList.add('light-mode');
            themeToggle.checked = true;
        } else {
            body.classList.remove('light-mode');
            themeToggle.checked = false;
        }

        themeToggle.addEventListener('change', () => {
            if (themeToggle.checked) {
                body.classList.add('light-mode');
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.remove('light-mode');
                localStorage.setItem('theme', 'dark');
            }
        });

        function resetHideTimeout() {
            clearTimeout(hideTimeout);
            header.classList.remove('hidden');
            hideTimeout = setTimeout(() => {
                if (window.scrollY === lastScrollY) {
                    header.classList.add('hidden');
                }
            }, 3000);
        }

        window.addEventListener('scroll', () => {
            lastScrollY = window.scrollY;
            resetHideTimeout();
        });

        window.addEventListener('DOMContentLoaded', resetHideTimeout);

        function toggleIpField() {
            const mode = document.getElementById("mode").value;
            const ipField = document.getElementById("ipField");
            if (ipField) {
                ipField.style.display = mode === "wifi" ? "block" : "none";
            }
        }

        function setStatus(message, isSuccess) {
            const statusMessageDiv = document.getElementById("statusMessage");
            if (!statusMessageDiv) return;

            statusMessageDiv.style.opacity = "0";

            setTimeout(() => {
                statusMessageDiv.innerText = message;
                statusMessageDiv.className = "";
                statusMessageDiv.classList.add("statusMessage");

                if (message) {
                    statusMessageDiv.classList.add(isSuccess ? "status-success" : "status-error");
                    statusMessageDiv.style.opacity = "1";

                    if (isSuccess) {
                        setTimeout(() => {
                            statusMessageDiv.style.opacity = "0";
                            setTimeout(() => statusMessageDiv.innerText = "", 500);
                        }, 5000);
                    }
                } else {
                     statusMessageDiv.style.opacity = "0";
                     setTimeout(() => statusMessageDiv.innerText = "", 5000);
                }
            }, 500);
        }


        const virtualDisplayCheckbox = document.getElementById("useVirtualDisplay");
        const nativeTaskbarCheckbox = document.getElementById("useNativeTaskbar");
        const samsungDexCheckbox = document.getElementById("useSamsungDex");
        const resolutionSelect = document.getElementById("resolution");
        const customResolutionInput = document.getElementById("customResolution");
        const dpiSelect = document.getElementById("dpi");
        const customDpiInput = document.getElementById("customDpi");
        const rotationLockSelect = document.getElementById("rotationLock");

        const virtualDisplayLabel = document.querySelector("label[for='useVirtualDisplay']");
        const nativeTaskbarLabel = document.querySelector("label[for='useNativeTaskbar']");
        const samsungDexLabel = document.querySelector("label[for='useSamsungDex']");
        const resolutionLabel = document.getElementById("resolutionLabel");
        const dpiLabel = document.getElementById("dpiLabel");
        const rotationLockLabel = document.getElementById("rotationLockLabel");

        function updateDisplayOptionsState() {
            if (!virtualDisplayCheckbox || !nativeTaskbarCheckbox || !samsungDexCheckbox ||
                !resolutionSelect || !customResolutionInput || !dpiSelect || !customDpiInput || !rotationLockSelect ||
                !virtualDisplayLabel || !nativeTaskbarLabel || !samsungDexLabel ||
                !resolutionLabel || !dpiLabel || !rotationLockLabel) {
                console.warn("One or more required elements for display options state not found.");
                return;
            }

            const virtualChecked = virtualDisplayCheckbox.checked;
            const nativeChecked = nativeTaskbarCheckbox.checked;
            const dexChecked = samsungDexCheckbox.checked;

            virtualDisplayCheckbox.disabled = nativeChecked || dexChecked;
            nativeTaskbarCheckbox.disabled = virtualChecked || dexChecked;
            samsungDexCheckbox.disabled = virtualChecked || nativeChecked;

            virtualDisplayLabel.classList.toggle('disabled', nativeChecked || dexChecked);
            nativeTaskbarLabel.classList.toggle('disabled', virtualChecked || dexChecked);
            samsungDexLabel.classList.toggle('disabled', virtualChecked || nativeChecked);

            const disableResDpi = dexChecked;
            resolutionSelect.disabled = disableResDpi;
            customResolutionInput.disabled = disableResDpi;
            dpiSelect.disabled = disableResDpi;
            customDpiInput.disabled = disableResDpi;
            resolutionLabel.classList.toggle('disabled', disableResDpi);
            dpiLabel.classList.toggle('disabled', disableResDpi);

            const disableOrientation = nativeChecked || dexChecked;
            rotationLockSelect.disabled = disableOrientation;
            rotationLockLabel.classList.toggle('disabled', disableOrientation);
        }

        if (virtualDisplayCheckbox) virtualDisplayCheckbox.addEventListener("change", updateDisplayOptionsState);
        if (nativeTaskbarCheckbox) nativeTaskbarCheckbox.addEventListener("change", updateDisplayOptionsState);
        if (samsungDexCheckbox) samsungDexCheckbox.addEventListener("change", updateDisplayOptionsState);

        const noControlCheckbox = document.getElementById("noControl");
        const turnScreenOffCheckbox = document.getElementById("turnScreenOff");
        const powerOffOnCloseCheckbox = document.getElementById("powerOffOnClose");
        const turnScreenOffLabel = document.querySelector("label[for='turnScreenOff']");
        const powerOffOnCloseLabel = document.querySelector("label[for='powerOffOnClose']");

        if (noControlCheckbox && turnScreenOffCheckbox && powerOffOnCloseCheckbox && turnScreenOffLabel && powerOffOnCloseLabel) {
            noControlCheckbox.addEventListener("change", function() {
                if (this.checked) {
                    turnScreenOffCheckbox.disabled = true;
                    powerOffOnCloseCheckbox.disabled = true;
                    turnScreenOffCheckbox.checked = false;
                    powerOffOnCloseCheckbox.checked = false;
                    turnScreenOffLabel.classList.add('disabled');
                    powerOffOnCloseLabel.classList.add('disabled');
                } else {
                    turnScreenOffCheckbox.disabled = false;
                    powerOffOnCloseCheckbox.disabled = false;
                    turnScreenOffLabel.classList.remove('disabled');
                    powerOffOnCloseLabel.classList.remove('disabled');
                }
            });
        }

        window.addEventListener("DOMContentLoaded", () => {
            updateDisplayOptionsState();
            if (noControlCheckbox && noControlCheckbox.checked) {
                noControlCheckbox.dispatchEvent(new Event("change"));
            }
            toggleIpField();
		    updateRotateButtonState();
        });

        var coll = document.getElementsByClassName("collapsible");
        var i;
        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                    content.classList.remove('expanded');
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                    content.classList.add('expanded');
                }
            });
        }

        window.addEventListener('resize', function() {
            for (i = 0; i < coll.length; i++) {
                var content = coll[i].nextElementSibling;
                if (coll[i].classList.contains('active')) {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            }
        });

        var qrCode = null;
        let qrPollingInterval = null;

        // Update QR colors - kept for potential future use or if default was needed,
        // but showQrModal now hardcodes black/white for the QR graphic itself.
        // Modal text/background colors are handled by CSS variables and theme toggle.
        function updateQrColors() {
             console.log("updateQrColors called. QR graphic colors are fixed black/white. Modal colors update automatically via CSS variables.");
        }


        function showQrModal(message, qr_string) {
            const modalOverlay = document.getElementById("qrModalOverlay");
            const modalMessage = document.getElementById("qrModalMessage");
            const qrcodeDiv = document.getElementById("qrcode");
            const modalTitle = document.getElementById("qrModalTitle");
            const qrModalStatus = document.getElementById("qrModalStatus");
            const qrConnectButton = document.getElementById("qrConnectButton");
            const qrSpinner = document.getElementById("qrSpinner");

            if (!modalOverlay || !modalMessage || !qrcodeDiv || !modalTitle || !qrModalStatus || !qrConnectButton || !qrSpinner) {
                 console.error("QR Modal elements not found.");
                 setStatus("Internal application error: Missing QR modal elements.", false);
                 return;
            }

            modalTitle.innerText = "Connect Phone to PC (Wireless Debugging)";
            modalMessage.innerHTML = message.replace(/\n/g, '<br>');

            if (qrCode && typeof qrCode.clear === 'function') {
                qrCode.clear();
            }
            qrcodeDiv.innerHTML = "";
            qrCode = null;
            qrcodeDiv.dataset.qrText = "";

            console.log("Generating QR for:", qr_string);
            qrcodeDiv.dataset.qrText = qr_string;

            try {
                qrCode = new QRCode(qrcodeDiv, {
                    text: qr_string,
                    width: 180,
                    height: 180,
                    colorDark : "#000000",
                    colorLight : "#FFFFFF",
					correctLevel : QRCode.CorrectLevel.H
                });
                console.log("QR code generated with fixed black/white colors.");

            } catch (e) {
                 console.error("Failed to generate QR code:", e);
                 qrcodeDiv.innerHTML = "<p>Error generating QR code.</p>";
            }

            qrModalStatus.innerText = "Scan the QR code on your phone...";
            qrSpinner.style.display = "inline-block";
            qrConnectButton.classList.add("button-disabled");
            qrConnectButton.disabled = true;

            modalOverlay.style.display = "flex";

            startQrPolling();
        }

        async function hideQrModal() {
            const modalOverlay = document.getElementById("qrModalOverlay");
            if (modalOverlay) {
                modalOverlay.style.display = "none";
            }

             if (qrCode && typeof qrCode.clear === 'function') {
                qrCode.clear();
             }
             qrCode = null;
             const qrcodeDiv = document.getElementById("qrcode");
             if (qrcodeDiv) qrcodeDiv.dataset.qrText = "";
             qrcodeDiv.innerHTML = "";

             stopQrPolling();

             try {
                 await fetch('/cancel-qr-flow', { method: 'POST' });
                 console.log("QR flow cancellation signal sent to backend.");
             } catch (e) {
                 console.error("Failed to send QR flow cancellation signal:", e);
             }

			 console.log('QR modal hidden');
        }

        function startQrPolling() {
            stopQrPolling();
            console.log("Starting QR status polling...");
            qrPollingInterval = setInterval(pollQrStatus, 1000);
        }

        function stopQrPolling() {
            if (qrPollingInterval) {
                clearInterval(qrPollingInterval);
                qrPollingInterval = null;
                console.log("QR status polling stopped.");
            }
        }

        async function pollQrStatus() {
            const qrModalStatus = document.getElementById("qrModalStatus");
            const qrConnectButton = document.getElementById("qrConnectButton");
            const qrSpinner = document.getElementById("qrSpinner");

             if (!qrModalStatus || !qrConnectButton || !qrSpinner) {
                 console.error("Polling failed: QR modal elements not found.");
                 stopQrPolling();
                 return;
             }

            try {
                const response = await fetch('/qr-status');
                if (!response.ok) {
                     console.error(`Polling failed: HTTP status ${response.status}`);
                     qrModalStatus.innerText = `Error polling status: ${response.status}`;
                     qrSpinner.style.display = "none";
                     qrConnectButton.classList.add("button-disabled");
                     qrConnectButton.disabled = true;
                     stopQrPolling();
                     return;
                }
                const status = await response.json();

                if (status.qr_paired_successfully) {
                     if (!status.qr_connected_successfully) {
                         qrModalStatus.innerText = "Paired successfully! Connecting to device...";
                         qrSpinner.style.display = "inline-block";
                         qrConnectButton.classList.add("button-disabled");
                         qrConnectButton.disabled = true;
                     } else {
                        qrModalStatus.innerText = "Paired & Connected Successfully!";
                        qrSpinner.style.display = "none";
                        qrConnectButton.classList.remove("button-disabled");
                        qrConnectButton.disabled = false;
                        stopQrPolling();
                     }
                } else if (status.qr_error) {
                    qrModalStatus.innerText = `Pairing Error: ${status.qr_error}`;
                    qrSpinner.style.display = "none";
                    qrConnectButton.classList.add("button-disabled");
                    qrConnectButton.disabled = true;
                    stopQrPolling();
                } else {
                }

                if (status.qr_connected_successfully || status.qr_error) {
                     stopQrPolling();
                }

            } catch (error) {
                console.error("Polling error:", error);
                qrModalStatus.innerText = `Polling Error: ${error.message}`;
                qrSpinner.style.display = "none";
                qrConnectButton.classList.add("button-disabled");
                qrConnectButton.disabled = true;
                stopQrPolling();
            }
        }

        async function startQrPairing() {
            const pairButton = document.getElementById("pairButton");
             if (!pairButton) return;

            pairButton.classList.add("button-disabled");
            pairButton.disabled = true;
            setStatus("Initiating QR pairing flow...", true);

            try {
                const response = await fetch('/initiate-qr', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });

                const data = await response.json();

                if (data.success === false && data.needs_qr) {
                     setStatus(data.info || "Scan QR code on your phone.", true);
                     showQrModal(data.qr_message, data.qr_string);
                } else if (data.success === true && data.workflow_active) {
                     setStatus(data.info || "QR pairing flow already active.", true);
                     startQrPolling();
                     showQrModal("Checking status...", "dummy"); // Show modal with a placeholder
                }
                else {
                    setStatus(`Error initiating QR flow: ${data.message || 'Unknown error'}`, false);
                }

            } catch (error) {
                console.error("Failed to initiate QR pairing flow:", error);
                setStatus(`Error initiating QR flow: ${error.message}`, false);
            } finally {
                pairButton.classList.remove("button-disabled");
                pairButton.disabled = false;
            }
        }

        async function startScrcpyFromQr() {
            const qrConnectButton = document.getElementById("qrConnectButton");
            if (qrConnectButton.disabled) {
                console.warn("Attempted to start Scrcpy from QR modal but button is disabled.");
                return;
            }

            hideQrModal();
            startScrcpy();
        }

        async function startScrcpy() {
            const startButton = document.getElementById("startButton");
            const spinner = document.getElementById("spinner");
            const ipInput = document.getElementById("ipAddress");
            const scrcpyCommandDisplay = document.getElementById("scrcpyCommandDisplay");
            const statusMessageDiv = document.getElementById("statusMessage");

            if (!startButton || !spinner || !ipInput || !scrcpyCommandDisplay || !statusMessageDiv) {
                console.error("Required elements for startScrcpy not found.");
                setStatus("Internal application error: Missing elements.", false);
                return;
            }

            startButton.disabled = true;
            startButton.classList.add("button-disabled");
            spinner.style.display = "inline-block";
            setStatus("", true);
            hideQrModal();

            scrcpyCommandDisplay.innerText = "Detecting device and preparing...";

            try {
                const mode = document.getElementById("mode").value;
                let ipAddress = mode === "wifi" ? ipInput.value.trim() : null;

                setStatus(`Attempting to detect and connect via ${mode.toUpperCase()}...`, true);

                const detectResponse = await fetch('/detect-device', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode, ip: ipAddress })
                });

                const detectData = await detectResponse.json();

                if (!detectResponse.ok || !detectData.success) {
                    // Check if the failure is because QR pairing is needed
                     if (detectData.needs_qr) {
                         console.log("Device detection requires QR pairing.");
                         setStatus(detectData.info || "Wi-Fi connection failed. Scan QR code on your phone.", false);
                         showQrModal(detectData.qr_message, detectData.qr_string);
                         // Do NOT throw an error here, just exit the function to let the QR flow handle it
                         return;
                     } else {
                        // It's a different kind of detection error
                         throw new Error(detectData.message || `Device detection failed. HTTP status: ${detectResponse.status}`);
                     }
                }

                console.log("Device detection successful:", detectData);

                if (mode === "wifi" && detectData.ip) {
                    ipAddress = detectData.ip;
                    ipInput.value = ipAddress;
                    setStatus(`Device ${detectData.model || 'Unknown'} detected at ${ipAddress}. Preparing to start Scrcpy...`, true);
                } else {
                     setStatus(`Device ${detectData.model || 'Unknown'} detected. Preparing to start Scrcpy...`, true);
                }


                const resolution = document.getElementById("customResolution").value.trim() || document.getElementById("resolution").value;
                const dpi = document.getElementById("customDpi").value.trim() || document.getElementById("dpi").value;
                const bitrateValue = document.getElementById("customBitrate").value.trim();
                const bitrate = bitrateValue ? `-b ${bitrateValue}M` : document.getElementById("bitrate").value;
                const maxFps = document.getElementById("maxFps").value;
                const rotationLock = document.getElementById("rotationLock").value;

                const options = Array.from(document.querySelectorAll(".checkbox-group input[type='checkbox']:checked"))
                    .filter(input => !input.disabled)
                    .filter(input => input.id !== 'useVirtualDisplay' && input.id !== 'useNativeTaskbar' && input.id !== 'useSamsungDex')
                    .map(input => input.value);

                const useVirtualDisplay = document.getElementById("useVirtualDisplay") ? document.getElementById("useVirtualDisplay").checked : false;
                const useNativeTaskbar = document.getElementById("useNativeTaskbar") ? document.getElementById("useNativeTaskbar").checked : false;
                const useSamsungDex = document.getElementById("useSamsungDex") ? document.getElementById("useSamsungDex").checked : false;

                const scrcpyConfig = {
                    mode,
                    ip: ipAddress,
                    resolution,
                    dpi,
                    bitrate,
                    maxFps,
                    rotationLock,
                    options,
                    useVirtualDisplay,
                    useNativeTaskbar,
                    useSamsungDex
                };

                setStatus(`Starting Scrcpy session...`, true);

                const scrcpyResponse = await fetch('/start-scrcpy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(scrcpyConfig)
                });

                const scrcpyResultText = await scrcpyResponse.text();
                const parts = scrcpyResultText.split("---COMMAND---");
                const message = parts[0] ? parts[0].trim() : 'Scrcpy process initiated.';
                const commandText = parts[1] ? parts[1].trim() : "Command not available in response.";

                scrcpyCommandDisplay.innerText = commandText;

                const collapsibleButton = document.querySelector('.command-card .collapsible');
                const contentDiv = document.querySelector('.command-card .content');
                if (collapsibleButton && contentDiv && !collapsibleButton.classList.contains('active')) {
                    collapsibleButton.classList.add('active');
                     requestAnimationFrame(() => {
                        contentDiv.style.maxHeight = contentDiv.scrollHeight + "px";
                        contentDiv.classList.add('expanded');
                     });
                }


                if (!scrcpyResponse.ok) {
                    throw new Error(message || `Scrcpy start failed. HTTP status: ${scrcpyResponse.status}`);
                }

                setStatus(message, true);

            } catch (error) {
                console.error("Scrcpy start or detection error:", error);
                // Check if the error structure indicates QR is needed (e.g., from /detect-device)
                 const qrMatch = error.message.match(/{"success":\s*false,\s*"needs_qr":\s*true,.*?}/);
                 if (qrMatch) {
                      try {
                           const errorJson = JSON.parse(qrMatch[0]);
                           setStatus(errorJson.info || "Wi-Fi connection failed. Scan QR code on your phone.", false);
                           showQrModal(errorJson.qr_message, errorJson.qr_string);
                      } catch (parseError) {
                           console.error("Failed to parse QR error message as JSON:", parseError);
                           setStatus(`Error during Wi-Fi detection: ${error.message}`, false);
                      }
                 }
                else {
                     setStatus(`Error: ${error.message}`, false);
                     const scrcpyCommandDisplay = document.getElementById("scrcpyCommandDisplay");
                     if (scrcpyCommandDisplay && scrcpyCommandDisplay.innerText.includes("Generating")) {
                         scrcpyCommandDisplay.innerText = `Failed: ${error.message}`;
                     } else if (scrcpyCommandDisplay) {
                         scrcpyCommandDisplay.innerText += `\n\nError: ${error.message}`;
                     }
                      const collapsibleButton = document.querySelector('.command-card .collapsible');
                      const contentDiv = document.querySelector('.command-card .content');
                      if (collapsibleButton && contentDiv && !collapsibleButton.classList.contains('active')) {
                          collapsibleButton.classList.add('active');
                          requestAnimationFrame(() => {
                            contentDiv.style.maxHeight = contentDiv.scrollHeight + "px";
                            contentDiv.classList.add('expanded');
                          });
                      }
                }

            } finally {
                spinner.style.display = "none";
                startButton.disabled = false;
                startButton.classList.remove("button-disabled");
            }
        }

        async function updateApp() {
            const updateButton = document.getElementById("updateButton");
            const updateSpinner = document.getElementById("updateSpinner");
            const statusMessageDiv = document.getElementById("statusMessage");

            if (!updateButton || !updateSpinner || !statusMessageDiv) {
                console.error("Required elements for updateApp not found.");
                setStatus("Internal application error: Missing elements for update.", false);
                return;
            }

            updateButton.disabled = true;
            updateButton.classList.add("button-disabled");
            updateSpinner.style.display = "inline-block";
            setStatus("", true);

            try {
                setStatus("Checking for and applying updates...", true);
                const response = await fetch('/update-app', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });

                const resultText = await response.text();

                if (!response.ok) {
                    throw new Error(resultText || `HTTP error! status: ${response.status}`);
                }

                setStatus(resultText, true);

                if (resultText.toLowerCase().includes("successful") || resultText.toLowerCase().includes("updated") || resultText.toLowerCase().includes("restarting")) {
                    setTimeout(() => {
                        setStatus("Update complete. Please close this window and restart the server (e.g., re-run server.ps1).", true);
                    }, 3000);
                }

            } catch (error) {
                console.error("Update error:", error);
                setStatus(`Error updating: ${error.message}`, false);
            } finally {
                updateSpinner.style.display = "none";
                updateButton.disabled = false;
                updateButton.classList.remove("button-disabled");
            }
        }
		
		const rotateButton = document.getElementById("rotateButton");
		const rotateSpinner = document.getElementById("rotateSpinner");

		function updateRotateButtonState() {
			if (!rotateButton || !nativeTaskbarCheckbox) {
				console.warn("Rotate button or Native Taskbar checkbox not found.");
				return;
			}

			const nativeChecked = nativeTaskbarCheckbox.checked;
			rotateButton.disabled = !nativeChecked;
			rotateButton.classList.toggle("button-disabled", !nativeChecked);
		}

		async function rotateScreen() {
			if (!rotateButton || !rotateSpinner) {
				console.error("Rotate button or spinner not found.");
				setStatus("Internal application error: Missing rotate button elements.", false);
				return;
			}

			rotateButton.disabled = true;
			rotateButton.classList.add("button-disabled");
			rotateSpinner.style.display = "inline-block";
			setStatus("Rotating screen...", true);

			try {
				const response = await fetch('/rotate-screen', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({})
				});

				const data = await response.json();

				if (!response.ok || !data.success) {
					throw new Error(data.message || `Screen rotation failed. HTTP status: ${response.status}`);
				}

				setStatus(data.message, true);

			} catch (error) {
				console.error("Screen rotation error:", error);
				setStatus(`Error: ${error.message}`, false);
			} finally {
				rotateSpinner.style.display = "none";
				updateRotateButtonState(); // Re-evaluate button state
			}
		}

		// Update button state on checkbox changes
		if (nativeTaskbarCheckbox) {
			nativeTaskbarCheckbox.addEventListener("change", updateRotateButtonState);
		}
		if (virtualDisplayCheckbox) {
			virtualDisplayCheckbox.addEventListener("change", updateRotateButtonState);
		}
		if (samsungDexCheckbox) {
			samsungDexCheckbox.addEventListener("change", updateRotateButtonState);
		}
    </script>
</body>
</html>